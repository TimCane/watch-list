//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class GeneratedApiClientService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    collectionsAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<CollectionsResponse> {
        let url_ = this.baseUrl + "/api/Collections?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectionsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectionsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionsResponse>;
        }));
    }

    protected processCollectionsAll(response: HttpResponseBase): Observable<CollectionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CollectionsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    collectionsPOST(body: CreateCollectionRequest | undefined): Observable<CreateCollectionResponse> {
        let url_ = this.baseUrl + "/api/Collections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectionsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectionsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCollectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCollectionResponse>;
        }));
    }

    protected processCollectionsPOST(response: HttpResponseBase): Observable<CreateCollectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateCollectionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    collectionsGET(id: string): Observable<CollectionResponse> {
        let url_ = this.baseUrl + "/api/Collections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectionsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectionsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionResponse>;
        }));
    }

    protected processCollectionsGET(response: HttpResponseBase): Observable<CollectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CollectionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    collectionsPUT(id: string, body: UpdateCollectionRequest | undefined): Observable<UpdateCollectionResponse> {
        let url_ = this.baseUrl + "/api/Collections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectionsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectionsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCollectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCollectionResponse>;
        }));
    }

    protected processCollectionsPUT(response: HttpResponseBase): Observable<UpdateCollectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateCollectionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    collectionsDELETE(id: string): Observable<DeleteCollectionResponse> {
        let url_ = this.baseUrl + "/api/Collections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectionsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectionsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteCollectionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteCollectionResponse>;
        }));
    }

    protected processCollectionsDELETE(response: HttpResponseBase): Observable<DeleteCollectionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteCollectionResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    creditsAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<CreditsResponse> {
        let url_ = this.baseUrl + "/api/Credits?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreditsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreditsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditsResponse>;
        }));
    }

    protected processCreditsAll(response: HttpResponseBase): Observable<CreditsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreditsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    creditsPOST(body: CreateCreditRequest | undefined): Observable<CreateCreditResponse> {
        let url_ = this.baseUrl + "/api/Credits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreditsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreditsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCreditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCreditResponse>;
        }));
    }

    protected processCreditsPOST(response: HttpResponseBase): Observable<CreateCreditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateCreditResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    creditsGET(id: string): Observable<CreditResponse> {
        let url_ = this.baseUrl + "/api/Credits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreditsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreditsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditResponse>;
        }));
    }

    protected processCreditsGET(response: HttpResponseBase): Observable<CreditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreditResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    creditsPUT(id: string, body: UpdateCreditRequest | undefined): Observable<UpdateCreditResponse> {
        let url_ = this.baseUrl + "/api/Credits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreditsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreditsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCreditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCreditResponse>;
        }));
    }

    protected processCreditsPUT(response: HttpResponseBase): Observable<UpdateCreditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateCreditResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    creditsDELETE(id: string): Observable<DeleteCreditResponse> {
        let url_ = this.baseUrl + "/api/Credits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreditsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreditsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteCreditResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteCreditResponse>;
        }));
    }

    protected processCreditsDELETE(response: HttpResponseBase): Observable<DeleteCreditResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteCreditResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    genresAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<GenresResponse> {
        let url_ = this.baseUrl + "/api/Genres?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenresAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenresAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenresResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenresResponse>;
        }));
    }

    protected processGenresAll(response: HttpResponseBase): Observable<GenresResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenresResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    genresPOST(body: CreateGenreRequest | undefined): Observable<CreateGenreResponse> {
        let url_ = this.baseUrl + "/api/Genres";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenresPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenresPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateGenreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateGenreResponse>;
        }));
    }

    protected processGenresPOST(response: HttpResponseBase): Observable<CreateGenreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateGenreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    genresGET(id: string): Observable<GenreResponse> {
        let url_ = this.baseUrl + "/api/Genres/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenresGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenresGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreResponse>;
        }));
    }

    protected processGenresGET(response: HttpResponseBase): Observable<GenreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    genresPUT(id: string, body: UpdateGenreRequest | undefined): Observable<UpdateGenreResponse> {
        let url_ = this.baseUrl + "/api/Genres/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenresPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenresPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGenreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGenreResponse>;
        }));
    }

    protected processGenresPUT(response: HttpResponseBase): Observable<UpdateGenreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateGenreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    genresDELETE(id: string): Observable<DeleteGenreResponse> {
        let url_ = this.baseUrl + "/api/Genres/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenresDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenresDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteGenreResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteGenreResponse>;
        }));
    }

    protected processGenresDELETE(response: HttpResponseBase): Observable<DeleteGenreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteGenreResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    keywordsAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<KeywordsResponse> {
        let url_ = this.baseUrl + "/api/Keywords?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeywordsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeywordsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeywordsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeywordsResponse>;
        }));
    }

    protected processKeywordsAll(response: HttpResponseBase): Observable<KeywordsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KeywordsResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    keywordsPOST(body: CreateKeywordRequest | undefined): Observable<CreateKeywordResponse> {
        let url_ = this.baseUrl + "/api/Keywords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeywordsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeywordsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateKeywordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateKeywordResponse>;
        }));
    }

    protected processKeywordsPOST(response: HttpResponseBase): Observable<CreateKeywordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateKeywordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    keywordsGET(id: string): Observable<KeywordResponse> {
        let url_ = this.baseUrl + "/api/Keywords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeywordsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeywordsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeywordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeywordResponse>;
        }));
    }

    protected processKeywordsGET(response: HttpResponseBase): Observable<KeywordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KeywordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    keywordsPUT(id: string, body: UpdateKeywordRequest | undefined): Observable<UpdateKeywordResponse> {
        let url_ = this.baseUrl + "/api/Keywords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeywordsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeywordsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateKeywordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateKeywordResponse>;
        }));
    }

    protected processKeywordsPUT(response: HttpResponseBase): Observable<UpdateKeywordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateKeywordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    keywordsDELETE(id: string): Observable<DeleteKeywordResponse> {
        let url_ = this.baseUrl + "/api/Keywords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeywordsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeywordsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteKeywordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteKeywordResponse>;
        }));
    }

    protected processKeywordsDELETE(response: HttpResponseBase): Observable<DeleteKeywordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteKeywordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    languagesAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<LanguagesResponse> {
        let url_ = this.baseUrl + "/api/Languages?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguagesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguagesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguagesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguagesResponse>;
        }));
    }

    protected processLanguagesAll(response: HttpResponseBase): Observable<LanguagesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LanguagesResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPOST(body: CreateLanguageRequest | undefined): Observable<CreateLanguageResponse> {
        let url_ = this.baseUrl + "/api/Languages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguagesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguagesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateLanguageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateLanguageResponse>;
        }));
    }

    protected processLanguagesPOST(response: HttpResponseBase): Observable<CreateLanguageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateLanguageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    languagesGET(id: string): Observable<LanguageResponse> {
        let url_ = this.baseUrl + "/api/Languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguagesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguagesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageResponse>;
        }));
    }

    protected processLanguagesGET(response: HttpResponseBase): Observable<LanguageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LanguageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPUT(id: string, body: UpdateLanguageRequest | undefined): Observable<UpdateLanguageResponse> {
        let url_ = this.baseUrl + "/api/Languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguagesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguagesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLanguageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLanguageResponse>;
        }));
    }

    protected processLanguagesPUT(response: HttpResponseBase): Observable<UpdateLanguageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateLanguageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    languagesDELETE(id: string): Observable<DeleteLanguageResponse> {
        let url_ = this.baseUrl + "/api/Languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguagesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguagesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteLanguageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteLanguageResponse>;
        }));
    }

    protected processLanguagesDELETE(response: HttpResponseBase): Observable<DeleteLanguageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteLanguageResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    moviesAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<MoviesResponse> {
        let url_ = this.baseUrl + "/api/Movies?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoviesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoviesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MoviesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MoviesResponse>;
        }));
    }

    protected processMoviesAll(response: HttpResponseBase): Observable<MoviesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MoviesResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moviesPOST(body: CreateMovieRequest | undefined): Observable<CreateMovieResponse> {
        let url_ = this.baseUrl + "/api/Movies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoviesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoviesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMovieResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMovieResponse>;
        }));
    }

    protected processMoviesPOST(response: HttpResponseBase): Observable<CreateMovieResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateMovieResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    moviesGET(id: string): Observable<MovieResponse> {
        let url_ = this.baseUrl + "/api/Movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoviesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoviesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieResponse>;
        }));
    }

    protected processMoviesGET(response: HttpResponseBase): Observable<MovieResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MovieResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moviesPUT(id: string, body: UpdateMovieRequest | undefined): Observable<UpdateMovieResponse> {
        let url_ = this.baseUrl + "/api/Movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoviesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoviesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateMovieResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateMovieResponse>;
        }));
    }

    protected processMoviesPUT(response: HttpResponseBase): Observable<UpdateMovieResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateMovieResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    moviesDELETE(id: string): Observable<DeleteMovieResponse> {
        let url_ = this.baseUrl + "/api/Movies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoviesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoviesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteMovieResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteMovieResponse>;
        }));
    }

    protected processMoviesDELETE(response: HttpResponseBase): Observable<DeleteMovieResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteMovieResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    productionCompaniesAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<ProductionCompaniesResponse> {
        let url_ = this.baseUrl + "/api/ProductionCompanies?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCompaniesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCompaniesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductionCompaniesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductionCompaniesResponse>;
        }));
    }

    protected processProductionCompaniesAll(response: HttpResponseBase): Observable<ProductionCompaniesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductionCompaniesResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productionCompaniesPOST(body: CreateProductionCompanyRequest | undefined): Observable<CreateProductionCompanyResponse> {
        let url_ = this.baseUrl + "/api/ProductionCompanies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCompaniesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCompaniesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateProductionCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateProductionCompanyResponse>;
        }));
    }

    protected processProductionCompaniesPOST(response: HttpResponseBase): Observable<CreateProductionCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateProductionCompanyResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    productionCompaniesGET(id: string): Observable<ProductionCompanyResponse> {
        let url_ = this.baseUrl + "/api/ProductionCompanies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCompaniesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCompaniesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductionCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductionCompanyResponse>;
        }));
    }

    protected processProductionCompaniesGET(response: HttpResponseBase): Observable<ProductionCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductionCompanyResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productionCompaniesPUT(id: string, body: UpdateProductionCompanyRequest | undefined): Observable<UpdateProductionCompanyResponse> {
        let url_ = this.baseUrl + "/api/ProductionCompanies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCompaniesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCompaniesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateProductionCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateProductionCompanyResponse>;
        }));
    }

    protected processProductionCompaniesPUT(response: HttpResponseBase): Observable<UpdateProductionCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateProductionCompanyResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    productionCompaniesDELETE(id: string): Observable<DeleteProductionCompanyResponse> {
        let url_ = this.baseUrl + "/api/ProductionCompanies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCompaniesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCompaniesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteProductionCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteProductionCompanyResponse>;
        }));
    }

    protected processProductionCompaniesDELETE(response: HttpResponseBase): Observable<DeleteProductionCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteProductionCompanyResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skip (optional) 
     * @param take (optional) 
     * @param search (optional) 
     * @param sortField (optional) 
     * @param sortOrder (optional) 
     * @return Success
     */
    productionCountriesAll(skip: number | undefined, take: number | undefined, search: string | undefined, sortField: string | undefined, sortOrder: SortOrderEnum | undefined): Observable<ProductionCountriesResponse> {
        let url_ = this.baseUrl + "/api/ProductionCountries?";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCountriesAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCountriesAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductionCountriesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductionCountriesResponse>;
        }));
    }

    protected processProductionCountriesAll(response: HttpResponseBase): Observable<ProductionCountriesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductionCountriesResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productionCountriesPOST(body: CreateProductionCountryRequest | undefined): Observable<CreateProductionCountryResponse> {
        let url_ = this.baseUrl + "/api/ProductionCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCountriesPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCountriesPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateProductionCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateProductionCountryResponse>;
        }));
    }

    protected processProductionCountriesPOST(response: HttpResponseBase): Observable<CreateProductionCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateProductionCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    productionCountriesGET(id: string): Observable<ProductionCountryResponse> {
        let url_ = this.baseUrl + "/api/ProductionCountries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCountriesGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCountriesGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductionCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductionCountryResponse>;
        }));
    }

    protected processProductionCountriesGET(response: HttpResponseBase): Observable<ProductionCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProductionCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productionCountriesPUT(id: string, body: UpdateProductionCountryRequest | undefined): Observable<UpdateProductionCountryResponse> {
        let url_ = this.baseUrl + "/api/ProductionCountries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCountriesPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCountriesPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateProductionCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateProductionCountryResponse>;
        }));
    }

    protected processProductionCountriesPUT(response: HttpResponseBase): Observable<UpdateProductionCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateProductionCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    productionCountriesDELETE(id: string): Observable<DeleteProductionCountryResponse> {
        let url_ = this.baseUrl + "/api/ProductionCountries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductionCountriesDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductionCountriesDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteProductionCountryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteProductionCountryResponse>;
        }));
    }

    protected processProductionCountriesDELETE(response: HttpResponseBase): Observable<DeleteProductionCountryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteProductionCountryResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateRequest | undefined): Observable<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/Users/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponse>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthenticateResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<RegisterResponse> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reauthenticate(body: ReauthenticateRequest | undefined): Observable<ReauthenticateResponse> {
        let url_ = this.baseUrl + "/api/Users/reauthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReauthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReauthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReauthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReauthenticateResponse>;
        }));
    }

    protected processReauthenticate(response: HttpResponseBase): Observable<ReauthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReauthenticateResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPasswordReset(body: CheckPasswordResetRequest | undefined): Observable<CheckPasswordResetResponse> {
        let url_ = this.baseUrl + "/api/Users/check-password-reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPasswordReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPasswordReset(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckPasswordResetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckPasswordResetResponse>;
        }));
    }

    protected processCheckPasswordReset(response: HttpResponseBase): Observable<CheckPasswordResetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckPasswordResetResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequest | undefined): Observable<ForgotPasswordResponse> {
        let url_ = this.baseUrl + "/api/Users/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForgotPasswordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForgotPasswordResponse>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ForgotPasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ForgotPasswordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequest | undefined): Observable<ResetPasswordResponse> {
        let url_ = this.baseUrl + "/api/Users/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordResponse>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResetPasswordResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmEmailAddress(body: ConfirmEmailAddressRequest | undefined): Observable<ConfirmEmailAddressResponse> {
        let url_ = this.baseUrl + "/api/Users/confirm-email-address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmailAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmailAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfirmEmailAddressResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfirmEmailAddressResponse>;
        }));
    }

    protected processConfirmEmailAddress(response: HttpResponseBase): Observable<ConfirmEmailAddressResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConfirmEmailAddressResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestEmailAddressConfirmation(body: RequestEmailAddressConfirmationRequest | undefined): Observable<RequestEmailAddressConfirmationResponse> {
        let url_ = this.baseUrl + "/api/Users/request-email-address-confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestEmailAddressConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestEmailAddressConfirmation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestEmailAddressConfirmationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestEmailAddressConfirmationResponse>;
        }));
    }

    protected processRequestEmailAddressConfirmation(response: HttpResponseBase): Observable<RequestEmailAddressConfirmationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestEmailAddressConfirmationResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    whoAmI(): Observable<WhoAmIResponse> {
        let url_ = this.baseUrl + "/api/Users/whoami";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWhoAmI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWhoAmI(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WhoAmIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WhoAmIResponse>;
        }));
    }

    protected processWhoAmI(response: HttpResponseBase): Observable<WhoAmIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WhoAmIResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logout(): Observable<LogoutResponse> {
        let url_ = this.baseUrl + "/api/Users/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogoutResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogoutResponse>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<LogoutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LogoutResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    forceLogout(): Observable<ForceLogoutResponse> {
        let url_ = this.baseUrl + "/api/Users/force-logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForceLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForceLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForceLogoutResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForceLogoutResponse>;
        }));
    }

    protected processForceLogout(response: HttpResponseBase): Observable<ForceLogoutResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ForceLogoutResponse;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : _responseText as string;
            return throwException("The server was unable to process the request", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface AuthenticateRequest {
    emailAddress: string;
    password: string;
}

export interface AuthenticateResponse {
    bearerToken?: string | undefined;
    refreshToken?: string | undefined;
}

export interface CheckPasswordResetRequest {
    userPromptId: string;
}

export interface CheckPasswordResetResponse {
    success?: boolean;
}

export interface Collection {
    id?: string;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface CollectionResponse {
    collection?: Collection;
}

export interface CollectionsResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    collections?: Collection[] | undefined;
}

export interface ConfirmEmailAddressRequest {
    userPromptId: string;
}

export interface ConfirmEmailAddressResponse {
    success?: boolean;
}

export interface CreateCollectionRequest {
    name?: string | undefined;
}

export interface CreateCollectionResponse {
    collection?: Collection;
}

export interface CreateCreditRequest {
}

export interface CreateCreditResponse {
    credit?: Credit;
}

export interface CreateGenreRequest {
}

export interface CreateGenreResponse {
    genre?: Genre;
}

export interface CreateKeywordRequest {
}

export interface CreateKeywordResponse {
    keyword?: Keyword;
}

export interface CreateLanguageRequest {
}

export interface CreateLanguageResponse {
    language?: Language;
}

export interface CreateMovieRequest {
}

export interface CreateMovieResponse {
    movie?: Movie;
}

export interface CreateProductionCompanyRequest {
}

export interface CreateProductionCompanyResponse {
    productionCompany?: ProductionCompany;
}

export interface CreateProductionCountryRequest {
}

export interface CreateProductionCountryResponse {
    productionCountry?: ProductionCountry;
}

export interface Credit {
    id?: string;
    character?: string | undefined;
    gender?: string | undefined;
    name?: string | undefined;
    order?: number | undefined;
    type?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface CreditResponse {
    credit?: Credit;
}

export interface CreditsResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    credits?: Credit[] | undefined;
}

export interface DeleteCollectionResponse {
    success?: boolean;
}

export interface DeleteCreditResponse {
    success?: boolean;
}

export interface DeleteGenreResponse {
    success?: boolean;
}

export interface DeleteKeywordResponse {
    success?: boolean;
}

export interface DeleteLanguageResponse {
    success?: boolean;
}

export interface DeleteMovieResponse {
    success?: boolean;
}

export interface DeleteProductionCompanyResponse {
    success?: boolean;
}

export interface DeleteProductionCountryResponse {
    success?: boolean;
}

export interface ForceLogoutResponse {
    success?: boolean;
}

export interface ForgotPasswordRequest {
    emailAddress: string;
}

export interface ForgotPasswordResponse {
    success?: boolean;
}

export interface Genre {
    id?: string;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface GenreResponse {
    genre?: Genre;
}

export interface GenresResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    genres?: Genre[] | undefined;
}

export interface Keyword {
    id?: string;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface KeywordResponse {
    keyword?: Keyword;
}

export interface KeywordsResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    keywords?: Keyword[] | undefined;
}

export interface Language {
    id?: string;
    iso?: string | undefined;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface LanguageResponse {
    language?: Language;
}

export interface LanguagesResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    languages?: Language[] | undefined;
}

export interface LogoutResponse {
    success?: boolean;
}

export interface Movie {
    id?: string;
    adult?: boolean | undefined;
    budget?: number | undefined;
    homepage?: string | undefined;
    language?: Language;
    collection?: Collection;
    originalTitle?: string | undefined;
    overview?: string | undefined;
    releaseDate?: Date | undefined;
    revenue?: number | undefined;
    runtime?: number | undefined;
    tagLine?: string | undefined;
    title?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface MovieResponse {
    movie?: Movie;
}

export interface MoviesResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    movies?: Movie[] | undefined;
}

export interface ProductionCompaniesResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    productionCompanies?: ProductionCompany[] | undefined;
}

export interface ProductionCompany {
    id?: string;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface ProductionCompanyResponse {
    productionCompany?: ProductionCompany;
}

export interface ProductionCountriesResponse {
    skip?: number;
    take?: number;
    total?: number;
    search?: string | undefined;
    sortField?: string | undefined;
    sortOrder?: SortOrderEnum;
    productionCountries?: ProductionCountry[] | undefined;
}

export interface ProductionCountry {
    id?: string;
    iso?: string | undefined;
    name?: string | undefined;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface ProductionCountryResponse {
    productionCountry?: ProductionCountry;
}

export interface ReauthenticateRequest {
    refreshToken: string;
}

export interface ReauthenticateResponse {
    bearerToken?: string | undefined;
    refreshToken?: string | undefined;
}

export interface RegisterRequest {
    emailAddress: string;
    name: string;
    password: string;
}

export interface RegisterResponse {
    success?: boolean;
}

export interface RequestEmailAddressConfirmationRequest {
    emailAddress: string;
}

export interface RequestEmailAddressConfirmationResponse {
    success?: boolean;
}

export interface ResetPasswordRequest {
    userPromptId: string;
    newPassword: string;
}

export interface ResetPasswordResponse {
    success?: boolean;
}

export enum SortOrderEnum {
    Asc = "Asc",
    Desc = "Desc",
}

export interface UpdateCollectionRequest {
    name?: string | undefined;
}

export interface UpdateCollectionResponse {
    collection?: Collection;
}

export interface UpdateCreditRequest {
    character?: string | undefined;
    gender?: string | undefined;
    name?: string | undefined;
    order?: number;
    type?: string | undefined;
}

export interface UpdateCreditResponse {
    credit?: Credit;
}

export interface UpdateGenreRequest {
    name?: string | undefined;
}

export interface UpdateGenreResponse {
    genre?: Genre;
}

export interface UpdateKeywordRequest {
    name?: string | undefined;
}

export interface UpdateKeywordResponse {
    keyword?: Keyword;
}

export interface UpdateLanguageRequest {
    name?: string | undefined;
}

export interface UpdateLanguageResponse {
    language?: Language;
}

export interface UpdateMovieRequest {
    title?: string | undefined;
    overview?: string | undefined;
    releaseDate?: Date;
    runtime?: number;
}

export interface UpdateMovieResponse {
    movie?: Movie;
}

export interface UpdateProductionCompanyRequest {
    name?: string | undefined;
}

export interface UpdateProductionCompanyResponse {
    productionCompany?: ProductionCompany;
}

export interface UpdateProductionCountryRequest {
    iso?: string | undefined;
    name?: string | undefined;
}

export interface UpdateProductionCountryResponse {
    productionCountry?: ProductionCountry;
}

export interface User {
    emailAddress?: string | undefined;
    id?: string | undefined;
    name?: string | undefined;
    isAdmin?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
}

export interface WhoAmIResponse {
    user?: User;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}